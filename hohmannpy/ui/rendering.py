from __future__ import annotations
import time

import numpy as np
import pygfx as gfx
import rendercanvas.auto
import importlib.resources
import imageio.v3 as iio
import pylinalg as la
import scipy as sp

from . import camera
from .. import astro


class RenderEngine:
    r"""
    Base class for rendering simulations generated by :class:`~hohmannpy.astro.Mission`. Uses pygfx to generate navigable
    3D scenes which can be used to display orbits.

    These scenes are static, the Earth does not rotate and the entire orbit is displayed at once.

    Creating a :mod:`pygfx` application involves several steps. First a :class:`pygfx.Scene`,
    :class:`rendercanvas.auto.RenderCanvas`, and :class:`pygfx.renderers.WgpuRenderer` must be created.
    :class:`pygfx.Scene` must then be populated with objects, light sources, and optionally a skybox. Then
    :meth:`event_handler()` must be added to the canvas. This will allow keyboard inputs to be processed while the
    canvas is being rendered. :meth:`render()` must be called to actually display the application. Internally, this
    method calls :meth:`animate()` which orients the camera and renders the scene before recursively calling itself.
    However, these calls are all simply buffered until :func:`rendercanvas.auto.loop.run()` is called which takes over
    control of the program and begins to process the recursively buffered animation calls.

    Parameters
    ----------
    traj: np.ndarray
        A (3, N) array of position vectors where N corresponds to the number of discrete timesteps propagated when
        :class:`~hohmannpy.astro.Mission` . :meth:`~hohmannpy.astro.Mission.simulate()` is called. Positions should be
        in units of :math:`m`.
    draw_basis: bool
        Flag which indicates whether to draw the Earth-centered inertial basis vectors.
    draw_skybox: bool
        Flag which indicates whether space should be a black void or filled with stars.

    Attributes
    ----------
    scene: :class:`pygfx.Scene`
        The collection of graphical assets (objects, light sources, skyboxes, etc;) to render.
    canvas: :class:`rendercanvas.auto.RenderCanvas`
        Surface onto which the scene is rendered.
    camera: :class:`~hohmannpy.ui.OrbitalCamera`
        Movable camera that controls which part of :attr:`scene` is currently rendered. Added to :attr:`scene` via
        instantiating :class:`pygfx.OrbitController` with it as a parameter. This also adds mouse control functionality
        as the base camera class only allows for keyboard control in conjunction with :meth:`event_handler()`.
    renderer: :class:`pygfx.renderers.WgpuRenderer`
        Draws the portion of the :attr:`scene` currently visible through :attr:`camera`.
    earth: :class:`pygfx.Mesh`
        Earth object used as the central body for displayed orbits. Since this class generates static scenes this Earth
        does not rotate.
    orbit: :class:`pygfx.Line`
        Orbit object generated from the ``traj`` parameter.

    Notes
    -----
    The simulation uses Cartesian coordinates which are taken to align with an Earth-centered inertial basis. The units
    used for sizing objects are taken to be equivalent to :math:`km`.
    """

    def __init__(
            self,
            traj: np.ndarray,
            draw_basis: bool = False,
            draw_skybox: bool = True,
    ):
        # Create the canvas and renderer.
        self.canvas = rendercanvas.auto.RenderCanvas(size=(1280, 720), title="HohmannPy")
        self.renderer = gfx.renderers.WgpuRenderer(self.canvas)

        # Create the scene and add lighting and objects to it.
        self.scene = gfx.Scene()
        self.scene.add(gfx.AmbientLight(intensity=0.1))
        sunlight = gfx.DirectionalLight(intensity=2)
        sunlight.local.position = (100000, 0, 0)
        self.scene.add(sunlight)

        self.earth = self.create_earth()
        self.scene.add(self.earth)

        self.orbit = self.create_orbit(traj)
        self.scene.add(self.orbit)

        if draw_basis:  # Optionally display an ECI basis.
            x_axis, y_axis, z_axis = self.create_basis(length=8000)
            self.scene.add(x_axis)
            self.scene.add(y_axis)
            self.scene.add(z_axis)

        if draw_skybox:  # Optionally display a skybox.
            skybox = self.create_skybox()
            self.scene.add(skybox)

        # Create the camera.
        self.camera = camera.OrbitalCamera(
            fov=50,
            aspect=16/9,
            initial_radius=20000,
            min_radius=9000,
            radial_accel=50000,
            azimuth_accel=3 * np.pi / 2,
            elevation_accel=3 * np.pi / 2,
            radial_damping=100000,
            azimuth_damping=4 * np.pi,
            elevation_damping=4 * np.pi,
            max_radial_vel=50000,
            max_azimuth_vel=2 * np.pi,
            max_elevation_vel=2 * np.pi,
        )
        gfx.OrbitController(self.camera, register_events=self.renderer)  # Add mouse control.

        # Add event handling functionality.
        self.canvas.add_event_handler(self.event_handler, "key_down", "key_up")

    def animate(self):
        r"""
        Function called to launch graphical application.
        """

        self.camera.orient()
        self.renderer.render(self.scene, self.camera)
        self.canvas.request_draw(self.animate)

    def render(self):
        r"""
        Method called to launch the graphical application.

        Buffers a single call to :meth:`animate()` which generates the application and scene and then recursively
        buffers infinite additional calls to itself. Then calls :func:`rendercanvas.auto.loop.run()` which proceeds to
        process this buffer, acting as the frame update loop.
        """

        self.canvas.request_draw(self.animate)
        rendercanvas.auto.loop.run()

    def event_handler(self, event):
        r"""
        Method passed to :meth:`rendercanvas.auto.RenderCanvas.add_event_handler()` which turns user key presses into
        camera movement.

        The former dispatches buffered user input via the parameter ``event`` each frame. The event type is then
        identified and corresponding commands are executed.

        Parameters
        ----------
        event: dict
            Events are dispatched as a dictionary with two main attributes: ``event_type`` and ``key``. The former
            indicates what user action took place (key presses versus key releases) and assuming the action was key
            press the latter indicates which key was actually pressed.
        """

        if event["event_type"] == "key_down":
            key = event["key"].lower()
            match key:
                case "w":  # Rotate up.
                    self.camera.elevation_dynamics_flag = 1
                case "a":  # Rotate left.
                    self.camera.azimuth_dynamics_flag = -1
                case "s":  # Rotate down.
                    self.camera.elevation_dynamics_flag = -1
                case "d":  # Rotate right.
                    self.camera.azimuth_dynamics_flag = 1
                case "q":  # Zoom out.
                    self.camera.radial_dynamics_flag = 1
                case "e":  # Zoom in.
                    self.camera.radial_dynamics_flag = -1
        else:
            if event["event_type"] == "key_up":
                key = event["key"].lower()
                match key:
                    case "w":  # Rotate up.
                        self.camera.elevation_dynamics_flag = 0
                    case "a":  # Rotate left.
                        self.camera.azimuth_dynamics_flag = 0
                    case "s":  # Rotate down.
                        self.camera.elevation_dynamics_flag = 0
                    case "d":  # Rotate right.
                        self.camera.azimuth_dynamics_flag = 0
                    case "q":  # Zoom out.
                        self.camera.radial_dynamics_flag = 0
                    case "e":  # Zoom in.
                        self.camera.radial_dynamics_flag = 0

    # --------------
    # OBJECT METHODS
    # --------------
    def create_skybox(self):
        r"""
        Method which instantiates the skybox object.

        Returns
        -------
        skybox: :class:`pygfx.BackgroundSkyboxMaterial`
            Skybox object displayed in the scene's background.

        Notes
        -----
        The skybox used was generated using `Spacescape <https://sourceforge.net/projects/spacescape/>`_ by *petrorocket*.
        """

        # Import all six skybox faces.
        with importlib.resources.files("hohmannpy.resources").joinpath("skybox/skybox_right1.png").open("rb") as f:
            skybox_right1_img = iio.imread(f)
        with importlib.resources.files("hohmannpy.resources").joinpath("skybox/skybox_left2.png").open("rb") as f:
            skybox_left2_img = iio.imread(f)
        with importlib.resources.files("hohmannpy.resources").joinpath("skybox/skybox_top3.png").open("rb") as f:
            skybox_top3_img = iio.imread(f)
        with importlib.resources.files("hohmannpy.resources").joinpath("skybox/skybox_bottom4.png").open("rb") as f:
            skybox_bottom4_img = iio.imread(f)
        with importlib.resources.files("hohmannpy.resources").joinpath("skybox/skybox_front5.png").open("rb") as f:
            skybox_front5_img = iio.imread(f)
        with importlib.resources.files("hohmannpy.resources").joinpath("skybox/skybox_back6.png").open("rb") as f:
            skybox_back6_img = iio.imread(f)

        # Stack the faces.
        skybox_img = np.stack(
            [skybox_right1_img, skybox_left2_img, skybox_top3_img,
             skybox_bottom4_img, skybox_front5_img, skybox_back6_img],
            axis=0
        )

        # Create the skybox object.
        width = skybox_img.shape[1]
        height = skybox_img.shape[2]
        skybox = gfx.Background(
            None,
            gfx.BackgroundSkyboxMaterial(map=gfx.Texture(skybox_img, dim=2, size=(width, height, 6))),
        )

        return skybox

    def create_earth(self):
        r"""
        Method which instantiates the Earth object.

        Returns
        -------
        earth: :class:`pygfx.Mesh`
            Earth object used as the central body for displayed orbits. Since this class generates static scenes this
            Earth does not rotate.

        Notes
        -----
        The Earth texture used was purchased from `JHT'S Planetary Pixel Emporium <https://planetpixelemporium.com/earth.html>`_.
        """

        # Initialize the Earth texture.
        earth_mat = gfx.MeshPhongMaterial(shininess=5)
        with importlib.resources.files("hohmannpy.resources").joinpath("earth_texture_map.jpg").open("rb") as f:
            earth_img = iio.imread(f)
            earth_img = np.ascontiguousarray(np.flipud(earth_img))  # Need to flip array.
        earth_mat.map = gfx.Texture(earth_img, dim=2)

        # Create the Earth object using the texture.
        earth = gfx.Mesh(
            gfx.sphere_geometry(radius=6371, width_segments=64, height_segments=32),
            earth_mat
        )
        earth.local.rotation = la.quat_from_euler(
            (np.pi / 2, 0, 0), order="XYZ"
        ) # Rotate Earth since texture is 90 deg offset about x-axis, then offset terminator in new body frame.

        return earth

    def create_basis(self, length: float):
        r"""
        Method which instantiates the basis object.

        Parameters
        ----------
        length: float
            Length of the basis vectors in :math`km`.

        Returns
        -------
        basis: :class:`pygfx.Mesh`
            Earth-centered inertial basis axes.
        """

        x_axis = gfx.Geometry(positions=np.array([[0, 0, 0], [length, 0, 0]], dtype=np.float32))
        y_axis = gfx.Geometry(positions=np.array([[0, 0, 0], [0, length, 0]], dtype=np.float32))
        z_axis = gfx.Geometry(positions=np.array([[0, 0, 0], [0, 0, length]], dtype=np.float32))

        x_material = gfx.LineMaterial(thickness=3, color=gfx.Color("#FF0000"))
        y_material = gfx.LineMaterial(thickness=3, color=gfx.Color("#00FF00"))
        z_material = gfx.LineMaterial(thickness=3, color=gfx.Color("#0000FF"))

        return gfx.Line(x_axis, x_material), gfx.Line(y_axis, y_material), gfx.Line(z_axis, z_material)

    def create_orbit(self, traj: np.ndarray):
        r"""
        Method which instantiates the orbit object.

        Parameters
        ----------
        traj: np.ndarray
            A (3, N) array of position vectors where N corresponds to the number of discrete timesteps propagated when
            :class:`~hohmannpy.astro.Mission` . :meth:`~hohmannpy.astro.Mission.simulate()` is called. Positions should
            be in units of :math:`m`.

        Returns
        -------
        orbit: :class:`pygfx.Line`
            Orbit object generated from the ``traj`` parameter.
        """

        orbit = traj.T / 1000  # Scale to engine units (km).
        orbit = orbit.astype(np.float32)  # Data type needed by gfx.Geometry.

        return gfx.Line(gfx.Geometry(positions=orbit), gfx.LineMaterial(thickness=2, color=gfx.Color("#FF073A")))


class DynamicRenderEngine(RenderEngine):
    r"""
    An extension of :class:`~hohmannpy.ui.RenderEngine` which renders satellites which move along the simulated orbits.

    The orbital trajectory ``traj`` is converted into a 3D linear spline using :func:`scipy.interpolate.make_interp_spline`.
    On each timestep a satellite is then drawn at the corresponding point along this interpolated orbit. In addition,
    time controls are implemented so that the sim can be sped up or paused.

    Rotation of the Earth is also implemented. The Greenwich mean-sidereal time of the Earth at mission start is used to
    orient the Earth and the rotation is assumed to progress linearly from there for the remainder of the mission in
    accordance with the Earth's mean rotation rate.

    Parameters
    ----------
    traj: np.ndarray
        A (3, N) array of position vectors where N corresponds to the number of discrete timesteps propagated when
        :class:`~hohmannpy.astro.Mission` . :meth:`~hohmannpy.astro.Mission.simulate()` is called. Positions should be
        in units of :math:`m`.
    times: np.ndarray
        A (1, N) array of times corresponding to the positions in `traj`. These are local times with :math:`t=0` marking
        the start of propagation.
    initial_global_time: :class:`~hohmannpy.astro.Time`
        The initial UT1 time at which the mission began.
    draw_basis: bool
        Flag which indicates whether to draw the Earth-centered inertial basis vectors.
    draw_skybox: bool
        Flag which indicates whether space should be a black void or filled with stars.

    Attributes
    ----------
    scene: :class:`pygfx.Scene`
        The collection of graphical assets (objects, light sources, skyboxes, etc;) to render.
    canvas: :class:`rendercanvas.auto.RenderCanvas`
        Surface onto which the scene is rendered.
    camera: :class:`~hohmannpy.ui.OrbitalCamera`
        Movable camera that controls which part of :attr:`scene` is currently rendered. Added to :attr:`scene` via
        instantiating an orbit controller with it as a parameter. This also adds mouse control functionality as the base
        camera class only allows for keyboard control in conjunction with the parent class'
        :meth:`event_handler()` method.
    renderer: :class:`pygfx.renderers.WgpuRenderer`
        Draws the portion of the :attr:`scene` currently visible through :attr:`camera`.
    earth: :class:`pygfx.Mesh`
        Earth object used as the central body for displayed orbits.
    base_earth_rotation: :class:`pylinalg.Quaternion`
        Quaternion representing the initial rotation of the earth at ``initial_global_time`` with respect to the mean
        Vernal equinox. The Vernal equinox points in the x-direction of the scene coordinates.
    satellite: :class:`pygfx.Mesh`
        Spherical object representing the satellite.
    orbit: :class:`pygfx.Line`
        Orbit object generated from the ``traj`` parameter.
    orbit_spline: :class:`scipy.BSpline`
        Linear spline of the input trajectory ``traj``. Calling it via ``orbit_spline(time)`` returns the interpolated
        orbit at that time.
    initial_global_time: :class:`~hohmannpy.astro.Time`
        The initial Gregorian date and UT1 time at which the mission began.
    initial_local_time: float
        The real-world time at which the engine begins rendering (in seconds).
    local_time: float
        The current real-world time (in seconds).
    sim_time: float
        The time since the mission began (in seconds). This may vary from :attr:`local_time` because the sim may be sped
        up.
    final_sim_time: float
        The last timestep propagator for the mission. After this is reached the sim resets.
    speed_factor: float
        How much fast :attr:`sim_time` is compared to :attr:`local_time`.
    old_speed_factor: float
        The :attr:`speed_factor` before pausing is saved so that when the sim is unpaused the sim returns to the
        pre-pause :attr:`speed_factor`.

    See Also
    --------
    :class:`~hohmannpy.ui.RenderEngine` : Parent of this class which implements static rendering.
    """

    def __init__(
            self,
            traj: np.ndarray,
            times: np.ndarray,
            initial_global_time: astro.Time,
            draw_basis: bool = True,
            draw_skybox: bool = True,
    ):
        # Base installation.
        super().__init__(traj, draw_basis, draw_skybox)

        self.initial_global_time = initial_global_time
        self.initial_local_time = None  # Set during initial animation.
        self.local_time = None  # Set during initial animation.
        self.sim_time = 0
        self.final_sim_time = times[0, -1]
        self.speed_factor = 100
        self.old_speed_factor = 0

        # Generate the orbital spline.
        self.orbit_spline = sp.interpolate.make_interp_spline(times.squeeze(), traj.T / 1000, k=1)

        # Rotate the Earth to start at the correct GMST, this overwrites any base-class rotation.
        self.base_earth_rotation = la.quat_from_euler(
            (np.pi / 2, self.initial_global_time.gmst, 0), order="XYZ"
        )  # Rotate Earth since texture is 90 deg offset about x-axis, then offset terminator in new body frame.
        self.earth.local.rotation = self.base_earth_rotation

        # Add satellite.
        self.satellite = self.create_satellite()
        self.scene.add(self.satellite)
        self.satellite.local.position = self.orbit_spline(0)

        # Add additional event handling.
        self.canvas.add_event_handler(self.time_event_handler, "key_down")

    def animate(self):
        r"""
        See :class:`~hohmannpy.ui.RenderEngine` . :meth:`~hohmannpy.ui.RenderEngine.animate()`. This simply adds in
        :attr:`sim_time` marching as well as rotating the Earth and moving the satellite.
        """

        earth_rot = 7.292115e-5  # Mean rotation rate of the Earth in rad/s.

        # Update the sim time.
        old_local_time = self.local_time
        self.local_time = time.perf_counter()
        self.sim_time += (self.local_time - old_local_time) * self.speed_factor

        if self.sim_time > self.final_sim_time:  # Reset if necessary.
            self.initial_local_time = time.perf_counter()
            self.sim_time = 0

        # Rotate the Earth and move the satellite.
        self.earth.local.rotation = la.quat_mul(
            self.base_earth_rotation,
            la.quat_from_axis_angle((0, 1, 0), self.sim_time * earth_rot),
        )

        self.satellite.local.position = self.orbit_spline(self.sim_time)

        super().animate()

    def render(self):
        r"""
        See :class:`~hohmannpy.ui.RenderEngine` . :meth:`~hohmannpy.ui.RenderEngine.render()`.
        """

        self.initial_local_time = time.perf_counter()
        self.local_time = self.initial_local_time

        super().render()

    def time_event_handler(self, event):
        r"""
        Extension of the event handler from :class:`~hohmannpy.ui.RenderEngine` that adds in time controls.

        Parameters
        ----------
        event: dict
            Events are dispatched as a dictionary with two main attributes: ``event_type`` and ``key``. The former
            indicates what user action took place (key presses versus key releases) and assuming the action was key
            press the latter indicates which key was actually pressed.
        """

        if event["event_type"] == "key_down":
            key = event["key"].lower()
            match key:
                case "1":  # 1x speed.
                    self.speed_factor = 1
                case "2":  # 10x speed.
                    self.speed_factor = 10
                case "3":  # 100x speed.
                    self.speed_factor = 100
                case "4":  # 1000x speed.
                    self.speed_factor = 1000
                case "5":  # 10000x speed.
                    self.speed_factor = 10000
                case " ":  # Play/pause.
                    if self.speed_factor == 0:
                        self.speed_factor = self.old_speed_factor
                    else:
                        self.old_speed_factor = self.speed_factor
                        self.speed_factor = 0

    # --------------
    # OBJECT METHODS
    # --------------
    def create_satellite(self):
        r"""
        Method which instantiates the satellite object.

        Returns
        -------
        satellite: :class:`pygfx.Mesh`
           Satellite object which moves along the orbit.
        """

        sat_mat =  gfx.MeshPhongMaterial(color=gfx.Color("#FF073A"), flat_shading=True)
        satellite = gfx.Mesh(
            gfx.sphere_geometry(radius=300, width_segments=64, height_segments=32),
            sat_mat
        )

        return satellite
