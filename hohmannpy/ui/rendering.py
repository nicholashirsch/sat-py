from __future__ import annotations
import time

import numpy as np
import pygfx as gfx
import rendercanvas.auto
import importlib.resources
import imageio.v3 as iio
import pylinalg as la

from . import camera
from .. import astro


class RenderEngine:
    r"""
    Base class for rendering simulations generated by :class:`astro.Mission`. Uses pygfx to generate navigable 3D scenes
    which can be used to display orbits.

    These scenes are static, the Earth does not rotate and the entire orbit is displayed at once.

    Creating a :mod:`pygfx` application involves several steps. First a :class:`pygfx.Scene`,
    :class:`rendercanvas.auto.RenderCanvas`, and :class:`pygfx.renderers.WgpuRenderer` must be created.
    :class:`pygfx.Scene` must then be populated with objects, light sources, and optionally a skybox. Then
    :meth:`RenderEngine.event_handler()` must be added to the canvas. This will allow keyboard inputs to be processed
    while the canvas is being rendered. :meth:`RenderEngine.render()` must be called to actually display the
    application. Internally, this method calls :meth:`RenderEngine.animate()` which orients the camera and renders the
    scene before recursively calling itself. However, these calls are all simply buffered until
    :func:`rendercanvas.auto.loop.run()` is called which takes over control of the program and begins to process the
    recursively buffered animation calls.

    Parameters
    ----------
    traj: np.ndarray
        A (3, N) array of position vectors where N corresponds to the number of discrete timesteps propagated when
        :meth:`astro.Mission.simulate()` is called. Positions should be in units of :math:`m`.
    draw_basis: bool
        Flag which indicates whether to draw the Earth-centered inertial basis vectors.
    draw_skybox: bool
        Flag which indicates whether space should be a black void or filled with stars.

    Attributes
    ----------
    scene: :class:`pygfx.Scene`
        The collection of graphical assets (objects, light sources, skyboxes, etc;) to render.
    canvas: :class:`rendercanvas.auto.RenderCanvas`
        Surface onto which the scene is rendered.
    camera: :class:`ui.OrbitalCamera`
        Movable camera that controls which part of :attr:`RenderEngine.scene` is currently rendered. Added to
        :attr:`RenderEngine.scene` via instantiating :class:`pygfx.OrbitController` with it as a parameter. This also
        adds mouse control functionality as the base camera class only allows for keyboard control in conjunction with
        :meth:`RenderEngine.event_handler()`.
    renderer: :class:`pygfx.renderers.WgpuRenderer`
        Draws the portion of the :attr:`RenderEngine.scene` currently visible through :attr:`RenderEngine.camera`.
    earth: class:`pygfx.Mesh`
        Earth object used as the central body for displayed orbits. Since this class generates static scenes this Earth
        does not rotate.
    orbit: :class:`pygfx.Line`
        Orbit object generated from the ``traj`` parameter.

    Notes
    -----
    The simulation uses Cartesian coordinates which are taken to align with an Earth-centered inertial basis. The units
    used for sizing objects are taken to be equivalent to :math:`km`.
    """

    def __init__(
            self,
            traj: np.ndarray,
            draw_basis: bool = False,
            draw_skybox: bool = True,
    ):
        # Create the canvas and renderer.
        self.canvas = rendercanvas.auto.RenderCanvas(size=(1280, 720), title="HohmannPy")
        self.renderer = gfx.renderers.WgpuRenderer(self.canvas)

        # Create the scene and add lighting and objects to it.
        self.scene = gfx.Scene()
        self.scene.add(gfx.AmbientLight(intensity=0.1))
        sunlight = gfx.DirectionalLight(intensity=2)
        sunlight.local.position = (100000, 0, 0)
        self.scene.add(sunlight)

        self.earth = self.draw_earth()
        self.scene.add(self.earth)

        self.orbit = self.draw_orbit(traj)
        self.scene.add(self.orbit)

        if draw_basis:  # Optionally display an ECI basis.
            x_axis, y_axis, z_axis = self.draw_basis(length=8000)
            self.scene.add(x_axis)
            self.scene.add(y_axis)
            self.scene.add(z_axis)

        if draw_skybox:  # Optionally display a skybox.
            skybox = self.draw_skybox()
            self.scene.add(skybox)

        # Create the camera.
        self.camera = camera.OrbitalCamera(
            fov=50,
            aspect=16/9,
            initial_radius=20000,
            min_radius=9000,
            radial_accel=50000,
            azimuth_accel=3 * np.pi / 2,
            elevation_accel=3 * np.pi / 2,
            radial_damping=100000,
            azimuth_damping=4 * np.pi,
            elevation_damping=4 * np.pi,
            max_radial_vel=50000,
            max_azimuth_vel=2 * np.pi,
            max_elevation_vel=2 * np.pi,
        )
        gfx.OrbitController(self.camera, register_events=self.renderer)  # Add mouse control.

        # Add event handling functionality.
        self.canvas.add_event_handler(self.event_handler, "key_down", "key_up")

    def animate(self):
        self.camera.orient()
        self.renderer.render(self.scene, self.camera)
        self.canvas.request_draw(self.animate)

    def render(self):
        r"""
        Method called to launch the graphical application.

        Buffers a single call to :meth:`RenderEngine.animate()` which
        generates the application and scene and then recursively buffers infinite additional calls to itself. Then calls
        :func:`rendercanvas.auto.loop.run()` which proceeds to process this buffer, acting as the frame update loop.
        """

        self.canvas.request_draw(self.animate)
        rendercanvas.auto.loop.run()

    def event_handler(self, event):
        r"""
        Method passed to :meth:`rendercanvas.auto.RenderCanvas.add_event_handler()` to allow for event handling while
        the scene is rendered. The former dispatches buffered user input via the parameter ``event`` each frame. The
        event type is then identified and corresponding commands are executed.

        Parameters
        ----------
        event: dict
            Events are dispatched as a dictionary with two main attributes: ``event_type`` and ``key``. The former
            indicates what user action took place (key presses versus key releases) and assuming the action was key
            press the latter indicates which key was actually pressed.
        """

        if event["event_type"] == "key_down":
            key = event["key"].lower()
            match key:
                case "w":  # Rotate up.
                    self.camera.elevation_dynamics_flag = 1
                case "a":  # Rotate left.
                    self.camera.azimuth_dynamics_flag = -1
                case "s":  # Rotate down.
                    self.camera.elevation_dynamics_flag = -1
                case "d":  # Rotate right.
                    self.camera.azimuth_dynamics_flag = 1
                case "q":  # Zoom out.
                    self.camera.radial_dynamics_flag = 1
                case "e":  # Zoom in.
                    self.camera.radial_dynamics_flag = -1
        else:
            if event["event_type"] == "key_up":
                key = event["key"].lower()
                match key:
                    case "w":  # Rotate up.
                        self.camera.elevation_dynamics_flag = 0
                    case "a":  # Rotate left.
                        self.camera.azimuth_dynamics_flag = 0
                    case "s":  # Rotate down.
                        self.camera.elevation_dynamics_flag = 0
                    case "d":  # Rotate right.
                        self.camera.azimuth_dynamics_flag = 0
                    case "q":  # Zoom out.
                        self.camera.radial_dynamics_flag = 0
                    case "e":  # Zoom in.
                        self.camera.radial_dynamics_flag = 0

    # --------------
    # OBJECT METHODS
    # --------------
    def draw_earth(self):
        r"""
        Method which instantiates the Earth object.

        Returns
        -------
        earth: :class:`pygfx.Mesh`
            Earth object used as the central body for displayed orbits. Since this class generates static scenes this Earth
            does not rotate.

        Notes
        -----
        The Earth texture used was purchased from `JHT'S Planetary Pixel Emporium <https://planetpixelemporium.com/earth.html>`_.
        """

        # Initialize the Earth texture.
        earth_mat = gfx.MeshPhongMaterial(shininess=5)
        with importlib.resources.files("hohmannpy.resources").joinpath("earth_texture_map.jpg").open("rb") as f:
            earth_img = iio.imread(f)
            earth_img = np.ascontiguousarray(np.flipud(earth_img))  # Need to flip array.
        earth_mat.map = gfx.Texture(earth_img, dim=2)

        # Create the Earth object using the texture.
        earth = gfx.Mesh(
            gfx.sphere_geometry(radius=6371, width_segments=64, height_segments=32),
            earth_mat
        )
        earth.local.rotation = la.quat_from_euler(
            (np.pi / 2, 0, 0), order="XYZ"
        ) # Rotate Earth since texture is 90 deg offset about x-axis, then offset terminator in new body frame.

        return earth

    def draw_skybox(self):
        r"""
        Method which instantiates the skybox object.

        Returns
        -------
        skybox: :class:`pygfx.BackgroundSkyboxMaterial`
            Skybox object displayed in the scene's background.

        Notes
        -----
        The skybox used was generated using `Spacescape <https://sourceforge.net/projects/spacescape/>`_ by *petrorocket*.
        """

        # Import all six skybox faces.
        with importlib.resources.files("hohmannpy.resources").joinpath("skybox/skybox_right1.png").open("rb") as f:
            skybox_right1_img = iio.imread(f)
        with importlib.resources.files("hohmannpy.resources").joinpath("skybox/skybox_left2.png").open("rb") as f:
            skybox_left2_img = iio.imread(f)
        with importlib.resources.files("hohmannpy.resources").joinpath("skybox/skybox_top3.png").open("rb") as f:
            skybox_top3_img = iio.imread(f)
        with importlib.resources.files("hohmannpy.resources").joinpath("skybox/skybox_bottom4.png").open("rb") as f:
            skybox_bottom4_img = iio.imread(f)
        with importlib.resources.files("hohmannpy.resources").joinpath("skybox/skybox_front5.png").open("rb") as f:
            skybox_front5_img = iio.imread(f)
        with importlib.resources.files("hohmannpy.resources").joinpath("skybox/skybox_back6.png").open("rb") as f:
            skybox_back6_img = iio.imread(f)

        # Stack the faces.
        skybox_img = np.stack(
            [skybox_right1_img, skybox_left2_img, skybox_top3_img,
             skybox_bottom4_img, skybox_front5_img, skybox_back6_img],
            axis=0
        )

        # Create the skybox object.
        width = skybox_img.shape[1]
        height = skybox_img.shape[2]
        skybox = gfx.Background(
            None,
            gfx.BackgroundSkyboxMaterial(map=gfx.Texture(skybox_img, dim=2, size=(width, height, 6))),
        )

        return skybox

    def draw_basis(self, length: float):
        r"""
        Method which instantiates the basis object.

        Parameters
        ----------
        length: float
            Length of the basis vectors in :math`km`.

        Returns
        -------
        basis: :class:`pygfx.Mesh`
            Earth-centered inertial basis axes.
        """

        x_axis = gfx.Geometry(positions=np.array([[0, 0, 0], [length, 0, 0]], dtype=np.float32))
        y_axis = gfx.Geometry(positions=np.array([[0, 0, 0], [0, length, 0]], dtype=np.float32))
        z_axis = gfx.Geometry(positions=np.array([[0, 0, 0], [0, 0, length]], dtype=np.float32))

        x_material = gfx.LineMaterial(thickness=3, color=gfx.Color("#FF0000"))
        y_material = gfx.LineMaterial(thickness=3, color=gfx.Color("#00FF00"))
        z_material = gfx.LineMaterial(thickness=3, color=gfx.Color("#0000FF"))

        return gfx.Line(x_axis, x_material), gfx.Line(y_axis, y_material), gfx.Line(z_axis, z_material)

    def draw_orbit(self, traj: np.ndarray):
        r"""
        Method which instantiates the orbit object.

        Parameters
        ----------
        traj: np.ndarray
            A (3, N) array of position vectors where N corresponds to the number of discrete timesteps propagated when
            :meth:`astro.Mission.simulate()` is called. Positions should be in units of :math:`m`.

        Returns
        -------
        orbit: :class:`pygfx.Line`
            Orbit object generated from the ``traj`` parameter.
        """

        orbit = traj.T / 1000  # Scale to engine units (km).
        orbit = orbit.astype(np.float32)  # Data type needed by gfx.Geometry.

        return gfx.Line(gfx.Geometry(positions=orbit), gfx.LineMaterial(thickness=2, color=gfx.Color("#FF073A")))


class DynamicRenderEngine(RenderEngine):
    def __init__(
            self,
            traj: np.ndarray,
            initial_global_time: astro.Time,
            draw_basis: bool = True,
            draw_skybox: bool = True,
    ):
        # Base installation.
        super().__init__(traj, draw_basis, draw_skybox)

        self.initial_global_time = initial_global_time
        self.initial_local_time = None  # Set during initial animation.

        # Rotate the Earth to start at the correct GMST, this overwrites any base-class rotation.
        self.base_earth_rotation = la.quat_from_euler(
            (np.pi / 2, self.initial_global_time.gmst, 0), order="XYZ"
        )  # Rotate Earth since texture is 90 deg offset about x-axis, then offset terminator in new body frame.
        self.earth.local.rotation = self.base_earth_rotation

    def animate(self):
        earth_rot = 7.292115e-5  # Mean rotation rate of the Earth in radians.
        self.camera.orient()
        self.earth.local.rotation = la.quat_mul(
            self.base_earth_rotation,
            la.quat_from_axis_angle((0, 1, 0), (time.perf_counter() - self.initial_local_time) * earth_rot),
        )
        self.renderer.render(self.scene, self.camera)
        self.canvas.request_draw(self.animate)

    def render(self):
        self.initial_local_time = time.perf_counter()
        self.canvas.request_draw(self.animate)
        rendercanvas.auto.loop.run()

    # --------------
    # OBJECT METHODS
    # --------------
    def draw_satellite(self, position):
        pass
